 // PUT: api/orders/{id}/status
 [HttpPut("{id}/status")]
 [Authorize(Roles = "Admin")]
 [EnableRateLimiting("standard")]
 public async Task<IActionResult> UpdateOrderStatus(int id, [FromBody] UpdateOrderStatusDto statusDto)
 {
     try
     {
         if (!ModelState.IsValid)
         {
             return BadRequest(new ApiErrorResponse
             {
                 Message = "Invalid input",
                 ErrorMessages = ModelState.Values
                     .SelectMany(v => v.Errors)
                     .Select(e => e.ErrorMessage)
                     .ToArray()
             });
         }

         // Validate the status value
         if (!OrderStatus.AllowedValues.Contains(statusDto.Status))
         {
             return BadRequest(new ApiErrorResponse
             {
                 Message = "Invalid order status",
                 ErrorMessages = new[] { $"Valid statuses are: {string.Join(", ", OrderStatus.AllowedValues)}" }
             });
         }

         // Check if order exists
         if (!await _orderRepository.OrderExistsAsync(id))
         {
             return NotFound(new ApiErrorResponse
             {
                 Message = "Order not found",
                 ErrorMessages = new[] { $"Order with ID {id} does not exist" }
             });
         }

         // Update the order status
         var updateDto = new UpdateOrderInputDto
         {
             OrderStatus = statusDto.Status
         };

         var updatedOrder = await _orderRepository.UpdateOrderAsync(id, updateDto);

         return Ok(new ApiResponse<OrderDto>
         {
             Success = true,
             Message = "Order status updated successfully",
             Data = updatedOrder
         });
     }
     catch (Exception ex)
     {
         _logger.LogError(ex, "Error updating order status for order {OrderId}", id);
         return StatusCode(500, new ApiErrorResponse
         {
             Message = "An error occurred while updating the order status",
             ErrorMessages = new[] { ex.Message }
         });
     }
 }

 // PUT: api/orders/suborders/{id}/status
 [HttpPut("suborders/{id}/status")]
 [Authorize(Roles = "Admin,Seller")]
 [EnableRateLimiting("standard")]
 public async Task<IActionResult> UpdateSubOrderStatus(int id, [FromBody] UpdateSubOrderStatusDto statusDto)
 {
     try
     {
         if (!ModelState.IsValid)
         {
             return BadRequest(new ApiErrorResponse
             {
                 Message = "Invalid input",
                 ErrorMessages = ModelState.Values
                     .SelectMany(v => v.Errors)
                     .Select(e => e.ErrorMessage)
                     .ToArray()
             });
         }

         // Validate the status value
         if (!SubOrderStatus.AllowedValues.Contains(statusDto.Status))
         {
             return BadRequest(new ApiErrorResponse
             {
                 Message = "Invalid suborder status",
                 ErrorMessages = new[] { $"Valid statuses are: {string.Join(", ", SubOrderStatus.AllowedValues)}" }
             });
         }

         // For sellers, verify they own this suborder
         if (User.IsInRole("Seller"))
         {
             var sellerId = User.FindFirst("SellerId")?.Value;
             if (string.IsNullOrEmpty(sellerId) || !int.TryParse(sellerId, out int sellerIdInt))
             {
                 return Unauthorized(new ApiErrorResponse
                 {
                     Message = "Invalid seller credentials",
                     ErrorMessages = new[] { "You must be logged in as a seller to update a suborder" }
                 });
             }

             var subOrder = await _orderRepository.GetSubOrderByIdAsync(id);
             if (subOrder == null)
             {
                 return NotFound(new ApiErrorResponse
                 {
                     Message = "Suborder not found",
                     ErrorMessages = new[] { $"Suborder with ID {id} does not exist" }
                 });
             }

             if (subOrder.SellerId != sellerIdInt)
             {
                 return Forbid();
             }
         }

         // Update the suborder status
         var updateDto = new UpdateSubOrderInputDto
         {
             Status = statusDto.Status
         };

         var updatedSubOrder = await _orderRepository.UpdateSubOrderStatusAsync(id, updateDto);

         return Ok(new ApiResponse<SubOrderDto>
         {
             Success = true,
             Message = "Suborder status updated successfully",
             Data = updatedSubOrder
         });
     }
     catch (Exception ex)
     {
         _logger.LogError(ex, "Error updating status for suborder {SubOrderId}", id);
         return StatusCode(500, new ApiErrorResponse
         {
             Message = "An error occurred while updating the suborder status",
             ErrorMessages = new[] { ex.Message }
         });
     }
 }

   // POST: api/orders/{id}/cancel
  [HttpPost("{id}/cancel")]
  [Authorize(Roles = $"{UserRoles.Customer},{UserRoles.Admin}")]
  [EnableRateLimiting("standard")]
  public async Task<IActionResult> CancelOrder(int id)
  {
      try
      {
          // Get customer ID from the authenticated user
          var customerId = User.FindFirst("CustomerId")?.Value;
          if (string.IsNullOrEmpty(customerId) || !int.TryParse(customerId, out int customerIdInt))
          {
              return Unauthorized(new ApiErrorResponse
              {
                  Message = "Invalid customer credentials",
                  ErrorMessages = new string[] { "You must be logged in as a customer to cancel an order" }
              });
          }

          var result = await _orderRepository.CancelOrderAsync(id, customerIdInt);

          if (!result.Success)
          {
              return BadRequest(new ApiErrorResponse
              {
                  Message = "Failed to cancel order",
                  ErrorMessages = new string[] { result.Message }
              });
          }

          return Ok(new ApiResponse<object>
          {
              Success = true,
              Message = result.Message,
              Data = null
          });
      }
      catch (Exception ex)
      {
          _logger.LogError(ex, "Error canceling order {OrderId}", id);
          return StatusCode(500, new ApiErrorResponse
          {
              Message = "An error occurred while canceling the order",
              ErrorMessages = new string[] { ex.Message }
          });
      }
  }

  // POST: api/orders/suborders/{id}/cancel
  [HttpPost("suborders/{id}/cancel")]
  [Authorize(Roles = "Seller")]
  [EnableRateLimiting("standard")]
  public async Task<IActionResult> CancelSubOrder(int id, [FromQuery] int sellerId)
  {
      try
      {
          
          if (string.IsNullOrEmpty(sellerId.ToString()) || sellerId == 0)
          {
              return Unauthorized(new ApiErrorResponse
              {
                  Message = "Invalid seller credentials",
                  ErrorMessages = new string[] { "You must be logged in as a seller to cancel a suborder" }
              });
          }

          var result = await _orderRepository.CancelSubOrderAsync(id, sellerId);

          if (!result.Success)
          {
              return BadRequest(new ApiErrorResponse
              {
                  Message = "Failed to cancel suborder",
                  ErrorMessages = new string[] { result.Message }
              });
          }

          return Ok(new ApiResponse<object>
          {
              Success = true,
              Message = result.Message,
              Data = null
          });
      }
      catch (Exception ex)
      {
          _logger.LogError(ex, "Error canceling suborder {SubOrderId}", id);
          return StatusCode(500, new ApiErrorResponse
          {
              Message = "An error occurred while canceling the suborder",
              ErrorMessages = new string[] { ex.Message }
          });
      }
  }
  // GET: api/orders/customer/{customerId}